// c

#ifdef C_C_DEF_CPP
#error include only once
#endif
#define C_C_DEF_CPP

#include "def_h"
#include "def_debug"

#if !_is_cpp_
#error this should be used in cpp files
#endif

//------------------------------------------------------------------------------
// cpp structs

#define COMPARABLE_IMPL(s) \
  int s::compare(rc that) const

#define RET_COMPARE_IF_NE(v1,v2) \
  if (v1 < v2) return -1;        \
  if (v1 > v2) return +1;

#define RET_BOOL_IF_LT_GT(v1,v2) \
  if (v1 < v2) return true;      \
  if (v1 > v2) return false;

#define RET_COMPARE_IF_NE_THAT(v) \
  RET_COMPARE_IF_NE(v, that.v)

#define RET_COMPARABLES_IF_NE(o)   \
  for (int cmp = o.compare(that.o); cmp; ) \
    return cmp;

#define EQ_NE_IMPL(T) \
bool T::operator==(rc that) const { return 0 == compare(that); } \
bool T::operator!=(rc that) const { return 0 != compare(that); }

#define LGTE_IMPL(T) \
bool T::operator< (rc that) const { return 0 >  compare(that); } \
bool T::operator<=(rc that) const { return 0 >= compare(that); } \
bool T::operator> (rc that) const { return 0 <  compare(that); } \
bool T::operator>=(rc that) const { return 0 <= compare(that); }

#define COMP_OPS_IMPL(T) EQ_NE_IMPL(T) LGTE_IMPL(T)

#define DEF_EQ_NE_IMPL(T) \
bool T::operator==(rc that) const { return isDef() && that.isDef() && 0 == compare(that); } \
bool T::operator!=(rc that) const { return isDef() && that.isDef() && 0 != compare(that); }

#define DEF_LGTE_IMPL(T) \
bool T::operator< (rc that) const { return isDef() && that.isDef() && 0 >  compare(that); } \
bool T::operator<=(rc that) const { return isDef() && that.isDef() && 0 >= compare(that); } \
bool T::operator> (rc that) const { return isDef() && that.isDef() && 0 <  compare(that); } \
bool T::operator>=(rc that) const { return isDef() && that.isDef() && 0 <= compare(that); }

#define DEF_COMP_OPS_IMPL(T) DEF_EQ_NE_IMPL(T) DEF_LGTE_IMPL(T)

//------------------------------------------------------------------------------
// unsafe

#include <utility>
namespace unsafe {
  template<typename T> void swap(T& t1, T& t2) {
    std::swap(mut(t1), mut(t2));
  }
}

//------------------------------------------------------------------------------
// eof
