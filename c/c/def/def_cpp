// c

#ifdef C_C_DEF_CPP
#error include only once
#endif
#define C_C_DEF_CPP

#include "def_h"
#include "def_debug"

#if !_is_cpp_
#error this should be used in cpp files
#endif

//------------------------------------------------------------------------------
// cpp structs

#define _c_con_impl(name, args) \
  c_##name::c_##name args

#define _c_des_impl(name)       \
  c_##name::~c_##name()

#define _c_mth_impl(name, type, mth, args) \
  type c_##name::mth args

#define COMPARABLE_IMPL(s) \
  int s::compare(rc that) const

#define RET_COMPARE_IF_NE(v1,v2) \
  if (v1 < v2) return -1;        \
  if (v1 > v2) return +1;

#define RET_BOOL_IF_LT_GT(v1,v2) \
  if (v1 < v2) return true;      \
  if (v1 > v2) return false;

#define RET_COMPARE_IF_NE_THAT(v) \
  RET_COMPARE_IF_NE(v, that.v)

#define RET_COMPARABLES_IF_NE(o)   \
  for (int cmp = o.compare(that.o); cmp; ) \
    return cmp;

#define EQ_NE_IMPL(T) \
bool T::operator==(rc that) const { return 0 == compare(that); } \
bool T::operator!=(rc that) const { return 0 != compare(that); }

#define DEF_EQ_NE_IMPL(T) \
bool T::operator==(rc that) const { return isDef() && that.isDef() && 0 == compare(that); } \
bool T::operator!=(rc that) const { return isDef() && that.isDef() && 0 != compare(that); }

//------------------------------------------------------------------------------
// unsafe

#include <utility>
namespace unsafe {
  template<typename T> void swap(T& t1, T& t2) {
    std::swap(mut(t1), mut(t2));
  }
}

//------------------------------------------------------------------------------
// eof
