// c - inculde into .h files; data declarations

#ifndef C_C_H_DATA
#define C_C_H_DATA

#include "h"

//------------------------------------------------------------------------------
// names

#define CAT_(a, b, c) a ## b ## c
#define CAT3(a, b, c) CAT_(a, b, c)

#define NS_NAME_C   CAT3(DATA_NS, _, DATA_NAME)
#define NS_NAME_CPP CAT3(DATA_NS, :, DATA_NAME)

//------------------------------------------------------------------------------
// declarations

// "C" ns-prefixed struct with the very default constructor ...
#define _c_data     \
  EXTERN_C struct NS_NAME_C {
#define _c_data_end \
  }; EXTERN_C_END

// ... that has only immutable data ...
#define _c_var(typ, name)     \
  typ const name;
#define _c_ptr(typ, name)     \
  typ const * const name;

#define _var _c_var
#define _ptr _c_ptr

// ... and perhaps constructors ...
#if _is_cpp_
#define _c_con(...) NS_NAME_C(__VA_ARGS__);
#else
#define _c_con
#endif

// ... in cpp ...
#if _is_cpp_

// ... with handy typedefs ...
#define _typedefs(s)      \
  typedef s typ;          \
  typedef typ& ref;       \
  typedef typ const& rc;  \
  typedef typ&& rval;

#define _cpp_struct_typedefs _typedefs(DATA_NAME)

// ... extended ...
#define _cpp_struct     \
  namespace DATA_NS {   \
  struct DATA_NAME : NS_NAME_C { _cpp_struct_typedefs using c_base = NS_NAME_C;
#define _cpp_struct_end \
  };}

// ... by constructors and destructor ...
#define _con(...)  \
  DATA_NAME(__VA_ARGS__);
#define _des        \
 ~DATA_NAME();

// ... methods ...
#define _mth_inline(typ, mth, args, ...)  \
  typ mth args const { __VA_ARGS__ }
#define _mth(typ, mth, args)              \
  typ mth args const;

#define _mth_mut_inline(typ, mth, args, ...)  \
  typ mth args { __VA_ARGS__ }
#define _mth_mut(typ, mth, args)              \
  typ mth args;

#define _fry(typ, mth, args) \
  static typ mth args;

#define _cst(typ, name) \
  static _var(typ, name)

// ... operators ...
#define _op_inline(op, expr)  \
  operator op const { return expr; }
#define _op(op)               \
  operator op const;

#define _op_mut_inline(op, expr)  \
  operator op { return expr; }
#define _op_mut(op)               \
  operator op;

// ... not covered by the above ...
#define _dcl(...)     __VA_ARGS__
#define _ns_dcl(...)  namespace DATA_NS { __VA_ARGS__ }

#else

#define _typedefs
#define _cpp_struct_typedefs
#define _cpp_struct
#define _cpp_struct_end
#define _con(...)
#define _des
#define _mth(typ, mth, args)
#define _mth_inline(typ, mth, args, code)
#define _mth_mut(typ, mth, args)
#define _mth_mut_inline(typ, mth, args, code)
#define _op(op)
#define _op_inline(op, code)
#define _op_mut(op)
#define _op_mut_inline(op, code)
#define _extra(...)
#define _ns_extra(...)

#endif

//------------------------------------------------------------------------------
// cpp subclassing

#if _is_cpp_

#define _struct _struct_pref()
#define _struct_pref(pref)     \
  namespace DATA_NS { pref struct DATA_NAME { _cpp_struct_typedefs
#define _struct_end \
  };}

#define _iface     \
  _struct virtual ~DATA_NAME();
#define _iface_end \
  };}

#define _iface_mth(typ, mth, args)     \
  virtual typ mth args const = 0;
#define _iface_mth_mut(typ, mth, args) \
  virtual typ mth args = 0;

#define _struct_sub_pre_pre(pre,pre_s,s)  \
  namespace DATA_NS { pre struct DATA_NAME : pre_s s { _cpp_struct_typedefs using base = s;

#define _struct_sub(s)         _struct_sub_pre_pre(,,s)
#define _struct_sub_retempl(s) _struct_sub_pre_pre(template <typename T>,protected,s)
#define _struct_sub_end        };}

#define sub_struct(s, b) struct s : b { _typedefs(s) using base = b;
#define sub_struct_end };

#define sub_struct_reimpl(s, b) struct s : protected b { _typedefs(s) using base = b; \
  base const& base_rc() const { return *this; }
#define sub_struct_reimpl_end };

#else

#define _struct
#define _struct_pref
#define _struct_end

#define _iface
#define _iface_end
#define _iface_mth(typ, mth, args)
#define _iface_mth_mut(typ, mth, args)

#define _struct_sub(s)
#define _struct_sub_pref(s)
#define _struct_sub_end

#endif

//------------------------------------------------------------------------------
// handy helpers

#if _is_cpp_

#define WITH_C_BASE_CONS using c_base::c_base;
#define WITH_BASE_CONS   using base::base;

#define NO_MOVE(s)              \
  s(rval)           = delete;   \
  r operator=(rval) = delete;

#define NO_COPY(s)              \
  s(rc)               = delete; \
  ref operator=(rc)   = delete; \
  ref operator=(rval) = delete;

#define NO_GEN(s)               \
  s(rc)               = delete; \
  ref operator=(rc)   = delete; \
  s(rval)             = delete; \
  ref operator=(rval) = delete;

#define COMPARABLE              \
  int compare(rc)     const;
#define EQ_NE                   \
  bool operator==(rc) const;    \
  bool operator!=(rc) const;
#define LGTE                    \
  bool operator< (rc) const;    \
  bool operator<=(rc) const;    \
  bool operator> (rc) const;    \
  bool operator>=(rc) const;

#define COMP_OPS EQ_NE LGTE

#define _cpp_code(...) __VA_ARGS__
#define _cpp_private  private:

#else

#define BASE(s)
#define NO_MOVE(s)
#define NO_COPY(s)
#define NO_GEN(s)
#define COMPARABLE
#define EQ_NE

#define _cpp_code(...)
#define _cpp_private

#endif

#if _is_cpp_

// make a type mutable
template <typename T> struct mut_typ            { typedef T typ; };
template <typename T> struct mut_typ<T const>   { typedef T typ; };

// make a var mutable
template <typename T> T*& mut(T const*const& t) { return const_cast<T*&>(t); }
template <typename T> T&  mut(T const& t)       { return const_cast<T&> (t); }

#endif

//------------------------------------------------------------------------------
#endif
// eof
