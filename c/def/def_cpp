// c

#ifdef C_DEF_CPP
#error include only once
#endif
#define C_DEF_CPP

#include "def_h"

#if !_c_cpp_
#error this should be used in cpp files
#endif

//------------------------------------------------------------------------------
// cpp structs

#define _c_con_impl(name, args) \
  c_##name::c_##name args

#define _c_des_impl(name)       \
  c_##name::~c_##name()

#define _c_mth_impl(name, type, mth, args) \
  type c_##name::mth args

#define COMPARABLE_IMPL(s) \
  int s::compare(rc that) const

#define RETURN_COMPARE_UNEQUAL(v1,v2) \
  if (v1 < v2) return -1;             \
  if (v1 > v2) return +1;

#define RETURN_COMPARE_UNEQUAL_THAT(v) \
  RETURN_COMPARE_UNEQUAL(v, that.v)

#define RETURN_COMPARABLES_UNEQUAL(o)   \
  for (int cmp = o.compare(that.o); cmp; ) \
    return cmp;

#define EQ_NE_IMPL(s) \
bool T::operator==(rc that) const { return 0 == compare(that); } \
bool T::operator!=(rc that) const { return 0 != compare(that); }

#define DEF_EQ_NE_IMPL(T) \
bool T::operator==(rc that) const { return isDef() && that.isDef() && 0 == compare(that); } \                                                       \
bool T::operator!=(rc that) const { return isDef() && that.isDef() && 0 != compare(that); }

//------------------------------------------------------------------------------
// unsafe

#include <utility>
namespace unsafe {
  template<typename T> void swap(T& t1, T& t2) {
    std::swap(mut(t1), mut(t2));
  }
}

//------------------------------------------------------------------------------
// eof
